// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `oak_shared.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;
#[derive(PartialEq, Clone, Default)]
pub struct Vec3 {
    // message fields
    pub x: f32,
    pub y: f32,
    pub z: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vec3 {
    fn default() -> &'a Vec3 {
        <Vec3 as ::protobuf::Message>::default_instance()
    }
}

impl Vec3 {
    pub fn new() -> Vec3 {
        ::std::default::Default::default()
    }

    // float x = 1;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float y = 2;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }

    // float z = 3;


    pub fn get_z(&self) -> f32 {
        self.z
    }
    pub fn clear_z(&mut self) {
        self.z = 0.;
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = v;
    }
}

impl ::protobuf::Message for Vec3 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 5;
        }
        if self.y != 0. {
            my_size += 5;
        }
        if self.z != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0. {
            os.write_float(1, self.x)?;
        }
        if self.y != 0. {
            os.write_float(2, self.y)?;
        }
        if self.z != 0. {
            os.write_float(3, self.z)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vec3 {
        Vec3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x",
                |m: &Vec3| { &m.x },
                |m: &mut Vec3| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y",
                |m: &Vec3| { &m.y },
                |m: &mut Vec3| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "z",
                |m: &Vec3| { &m.z },
                |m: &mut Vec3| { &mut m.z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Vec3>(
                "Vec3",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static Vec3 {
        static instance: ::protobuf::rt::LazyV2<Vec3> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Vec3::new)
    }
}

impl ::protobuf::Clear for Vec3 {
    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vec3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vec3 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct GameStatSaveGameData {
    // message fields
    pub stat_value: i32,
    pub stat_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameStatSaveGameData {
    fn default() -> &'a GameStatSaveGameData {
        <GameStatSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl GameStatSaveGameData {
    pub fn new() -> GameStatSaveGameData {
        ::std::default::Default::default()
    }

    // int32 stat_value = 1;


    pub fn get_stat_value(&self) -> i32 {
        self.stat_value
    }
    pub fn clear_stat_value(&mut self) {
        self.stat_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: i32) {
        self.stat_value = v;
    }

    // string stat_path = 2;


    pub fn get_stat_path(&self) -> &str {
        &self.stat_path
    }
    pub fn clear_stat_path(&mut self) {
        self.stat_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_path(&mut self, v: ::std::string::String) {
        self.stat_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat_path(&mut self) -> &mut ::std::string::String {
        &mut self.stat_path
    }

    // Take field
    pub fn take_stat_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stat_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GameStatSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stat_value = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stat_path)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.stat_value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.stat_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.stat_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.stat_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.stat_value != 0 {
            os.write_int32(1, self.stat_value)?;
        }
        if !self.stat_path.is_empty() {
            os.write_string(2, &self.stat_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameStatSaveGameData {
        GameStatSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "stat_value",
                |m: &GameStatSaveGameData| { &m.stat_value },
                |m: &mut GameStatSaveGameData| { &mut m.stat_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stat_path",
                |m: &GameStatSaveGameData| { &m.stat_path },
                |m: &mut GameStatSaveGameData| { &mut m.stat_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GameStatSaveGameData>(
                "GameStatSaveGameData",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static GameStatSaveGameData {
        static instance: ::protobuf::rt::LazyV2<GameStatSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GameStatSaveGameData::new)
    }
}

impl ::protobuf::Clear for GameStatSaveGameData {
    fn clear(&mut self) {
        self.stat_value = 0;
        self.stat_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameStatSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameStatSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct InventoryCategorySaveData {
    // message fields
    pub base_category_definition_hash: u32,
    pub quantity: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InventoryCategorySaveData {
    fn default() -> &'a InventoryCategorySaveData {
        <InventoryCategorySaveData as ::protobuf::Message>::default_instance()
    }
}

impl InventoryCategorySaveData {
    pub fn new() -> InventoryCategorySaveData {
        ::std::default::Default::default()
    }

    // uint32 base_category_definition_hash = 1;


    pub fn get_base_category_definition_hash(&self) -> u32 {
        self.base_category_definition_hash
    }
    pub fn clear_base_category_definition_hash(&mut self) {
        self.base_category_definition_hash = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_category_definition_hash(&mut self, v: u32) {
        self.base_category_definition_hash = v;
    }

    // int32 quantity = 2;


    pub fn get_quantity(&self) -> i32 {
        self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = 0;
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: i32) {
        self.quantity = v;
    }
}

impl ::protobuf::Message for InventoryCategorySaveData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_category_definition_hash = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quantity = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.base_category_definition_hash != 0 {
            my_size += ::protobuf::rt::value_size(1, self.base_category_definition_hash, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.quantity != 0 {
            my_size += ::protobuf::rt::value_size(2, self.quantity, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.base_category_definition_hash != 0 {
            os.write_uint32(1, self.base_category_definition_hash)?;
        }
        if self.quantity != 0 {
            os.write_int32(2, self.quantity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InventoryCategorySaveData {
        InventoryCategorySaveData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "base_category_definition_hash",
                |m: &InventoryCategorySaveData| { &m.base_category_definition_hash },
                |m: &mut InventoryCategorySaveData| { &mut m.base_category_definition_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "quantity",
                |m: &InventoryCategorySaveData| { &m.quantity },
                |m: &mut InventoryCategorySaveData| { &mut m.quantity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InventoryCategorySaveData>(
                "InventoryCategorySaveData",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static InventoryCategorySaveData {
        static instance: ::protobuf::rt::LazyV2<InventoryCategorySaveData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InventoryCategorySaveData::new)
    }
}

impl ::protobuf::Clear for InventoryCategorySaveData {
    fn clear(&mut self) {
        self.base_category_definition_hash = 0;
        self.quantity = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InventoryCategorySaveData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InventoryCategorySaveData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct OakSDUSaveGameData {
    // message fields
    pub sdu_level: i32,
    pub sdu_data_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakSDUSaveGameData {
    fn default() -> &'a OakSDUSaveGameData {
        <OakSDUSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakSDUSaveGameData {
    pub fn new() -> OakSDUSaveGameData {
        ::std::default::Default::default()
    }

    // int32 sdu_level = 1;


    pub fn get_sdu_level(&self) -> i32 {
        self.sdu_level
    }
    pub fn clear_sdu_level(&mut self) {
        self.sdu_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_sdu_level(&mut self, v: i32) {
        self.sdu_level = v;
    }

    // string sdu_data_path = 2;


    pub fn get_sdu_data_path(&self) -> &str {
        &self.sdu_data_path
    }
    pub fn clear_sdu_data_path(&mut self) {
        self.sdu_data_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_sdu_data_path(&mut self, v: ::std::string::String) {
        self.sdu_data_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdu_data_path(&mut self) -> &mut ::std::string::String {
        &mut self.sdu_data_path
    }

    // Take field
    pub fn take_sdu_data_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sdu_data_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OakSDUSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sdu_level = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sdu_data_path)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sdu_level != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sdu_level, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sdu_data_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sdu_data_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sdu_level != 0 {
            os.write_int32(1, self.sdu_level)?;
        }
        if !self.sdu_data_path.is_empty() {
            os.write_string(2, &self.sdu_data_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakSDUSaveGameData {
        OakSDUSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sdu_level",
                |m: &OakSDUSaveGameData| { &m.sdu_level },
                |m: &mut OakSDUSaveGameData| { &mut m.sdu_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdu_data_path",
                |m: &OakSDUSaveGameData| { &m.sdu_data_path },
                |m: &mut OakSDUSaveGameData| { &mut m.sdu_data_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakSDUSaveGameData>(
                "OakSDUSaveGameData",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static OakSDUSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakSDUSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakSDUSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakSDUSaveGameData {
    fn clear(&mut self) {
        self.sdu_level = 0;
        self.sdu_data_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakSDUSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakSDUSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RegisteredDownloadableEntitlement {
    // message fields
    pub id: i32,
    pub consumed: u32,
    pub registered: bool,
    pub seen: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisteredDownloadableEntitlement {
    fn default() -> &'a RegisteredDownloadableEntitlement {
        <RegisteredDownloadableEntitlement as ::protobuf::Message>::default_instance()
    }
}

impl RegisteredDownloadableEntitlement {
    pub fn new() -> RegisteredDownloadableEntitlement {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // uint32 consumed = 2;


    pub fn get_consumed(&self) -> u32 {
        self.consumed
    }
    pub fn clear_consumed(&mut self) {
        self.consumed = 0;
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: u32) {
        self.consumed = v;
    }

    // bool registered = 3;


    pub fn get_registered(&self) -> bool {
        self.registered
    }
    pub fn clear_registered(&mut self) {
        self.registered = false;
    }

    // Param is passed by value, moved
    pub fn set_registered(&mut self, v: bool) {
        self.registered = v;
    }

    // bool seen = 4;


    pub fn get_seen(&self) -> bool {
        self.seen
    }
    pub fn clear_seen(&mut self) {
        self.seen = false;
    }

    // Param is passed by value, moved
    pub fn set_seen(&mut self, v: bool) {
        self.seen = v;
    }
}

impl ::protobuf::Message for RegisteredDownloadableEntitlement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.consumed = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.registered = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.seen = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.consumed != 0 {
            my_size += ::protobuf::rt::value_size(2, self.consumed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.registered != false {
            my_size += 2;
        }
        if self.seen != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.consumed != 0 {
            os.write_uint32(2, self.consumed)?;
        }
        if self.registered != false {
            os.write_bool(3, self.registered)?;
        }
        if self.seen != false {
            os.write_bool(4, self.seen)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisteredDownloadableEntitlement {
        RegisteredDownloadableEntitlement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &RegisteredDownloadableEntitlement| { &m.id },
                |m: &mut RegisteredDownloadableEntitlement| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "consumed",
                |m: &RegisteredDownloadableEntitlement| { &m.consumed },
                |m: &mut RegisteredDownloadableEntitlement| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "registered",
                |m: &RegisteredDownloadableEntitlement| { &m.registered },
                |m: &mut RegisteredDownloadableEntitlement| { &mut m.registered },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "seen",
                |m: &RegisteredDownloadableEntitlement| { &m.seen },
                |m: &mut RegisteredDownloadableEntitlement| { &mut m.seen },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisteredDownloadableEntitlement>(
                "RegisteredDownloadableEntitlement",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RegisteredDownloadableEntitlement {
        static instance: ::protobuf::rt::LazyV2<RegisteredDownloadableEntitlement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisteredDownloadableEntitlement::new)
    }
}

impl ::protobuf::Clear for RegisteredDownloadableEntitlement {
    fn clear(&mut self) {
        self.id = 0;
        self.consumed = 0;
        self.registered = false;
        self.seen = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisteredDownloadableEntitlement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisteredDownloadableEntitlement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct RegisteredDownloadableEntitlements {
    // message fields
    pub entitlement_source_asset_path: ::std::string::String,
    pub entitlement_ids: ::std::vec::Vec<i64>,
    pub entitlements: ::protobuf::RepeatedField<RegisteredDownloadableEntitlement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisteredDownloadableEntitlements {
    fn default() -> &'a RegisteredDownloadableEntitlements {
        <RegisteredDownloadableEntitlements as ::protobuf::Message>::default_instance()
    }
}

impl RegisteredDownloadableEntitlements {
    pub fn new() -> RegisteredDownloadableEntitlements {
        ::std::default::Default::default()
    }

    // string entitlement_source_asset_path = 1;


    pub fn get_entitlement_source_asset_path(&self) -> &str {
        &self.entitlement_source_asset_path
    }
    pub fn clear_entitlement_source_asset_path(&mut self) {
        self.entitlement_source_asset_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_entitlement_source_asset_path(&mut self, v: ::std::string::String) {
        self.entitlement_source_asset_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entitlement_source_asset_path(&mut self) -> &mut ::std::string::String {
        &mut self.entitlement_source_asset_path
    }

    // Take field
    pub fn take_entitlement_source_asset_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entitlement_source_asset_path, ::std::string::String::new())
    }

    // repeated int64 entitlement_ids = 2;


    pub fn get_entitlement_ids(&self) -> &[i64] {
        &self.entitlement_ids
    }
    pub fn clear_entitlement_ids(&mut self) {
        self.entitlement_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_entitlement_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.entitlement_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entitlement_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.entitlement_ids
    }

    // Take field
    pub fn take_entitlement_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.entitlement_ids, ::std::vec::Vec::new())
    }

    // repeated .OakSave.RegisteredDownloadableEntitlement entitlements = 3;


    pub fn get_entitlements(&self) -> &[RegisteredDownloadableEntitlement] {
        &self.entitlements
    }
    pub fn clear_entitlements(&mut self) {
        self.entitlements.clear();
    }

    // Param is passed by value, moved
    pub fn set_entitlements(&mut self, v: ::protobuf::RepeatedField<RegisteredDownloadableEntitlement>) {
        self.entitlements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entitlements(&mut self) -> &mut ::protobuf::RepeatedField<RegisteredDownloadableEntitlement> {
        &mut self.entitlements
    }

    // Take field
    pub fn take_entitlements(&mut self) -> ::protobuf::RepeatedField<RegisteredDownloadableEntitlement> {
        ::std::mem::replace(&mut self.entitlements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RegisteredDownloadableEntitlements {
    fn is_initialized(&self) -> bool {
        for v in &self.entitlements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entitlement_source_asset_path)?;
                }
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.entitlement_ids)?;
                }
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entitlements)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entitlement_source_asset_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entitlement_source_asset_path);
        }
        for value in &self.entitlement_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.entitlements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entitlement_source_asset_path.is_empty() {
            os.write_string(1, &self.entitlement_source_asset_path)?;
        }
        for v in &self.entitlement_ids {
            os.write_int64(2, *v)?;
        };
        for v in &self.entitlements {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisteredDownloadableEntitlements {
        RegisteredDownloadableEntitlements::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entitlement_source_asset_path",
                |m: &RegisteredDownloadableEntitlements| { &m.entitlement_source_asset_path },
                |m: &mut RegisteredDownloadableEntitlements| { &mut m.entitlement_source_asset_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "entitlement_ids",
                |m: &RegisteredDownloadableEntitlements| { &m.entitlement_ids },
                |m: &mut RegisteredDownloadableEntitlements| { &mut m.entitlement_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegisteredDownloadableEntitlement>>(
                "entitlements",
                |m: &RegisteredDownloadableEntitlements| { &m.entitlements },
                |m: &mut RegisteredDownloadableEntitlements| { &mut m.entitlements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisteredDownloadableEntitlements>(
                "RegisteredDownloadableEntitlements",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static RegisteredDownloadableEntitlements {
        static instance: ::protobuf::rt::LazyV2<RegisteredDownloadableEntitlements> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisteredDownloadableEntitlements::new)
    }
}

impl ::protobuf::Clear for RegisteredDownloadableEntitlements {
    fn clear(&mut self) {
        self.entitlement_source_asset_path.clear();
        self.entitlement_ids.clear();
        self.entitlements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisteredDownloadableEntitlements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisteredDownloadableEntitlements {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ChallengeStatSaveGameData {
    // message fields
    pub current_stat_value: i32,
    pub challenge_stat_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChallengeStatSaveGameData {
    fn default() -> &'a ChallengeStatSaveGameData {
        <ChallengeStatSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeStatSaveGameData {
    pub fn new() -> ChallengeStatSaveGameData {
        ::std::default::Default::default()
    }

    // int32 current_stat_value = 1;


    pub fn get_current_stat_value(&self) -> i32 {
        self.current_stat_value
    }
    pub fn clear_current_stat_value(&mut self) {
        self.current_stat_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_stat_value(&mut self, v: i32) {
        self.current_stat_value = v;
    }

    // string challenge_stat_path = 2;


    pub fn get_challenge_stat_path(&self) -> &str {
        &self.challenge_stat_path
    }
    pub fn clear_challenge_stat_path(&mut self) {
        self.challenge_stat_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge_stat_path(&mut self, v: ::std::string::String) {
        self.challenge_stat_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_stat_path(&mut self) -> &mut ::std::string::String {
        &mut self.challenge_stat_path
    }

    // Take field
    pub fn take_challenge_stat_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.challenge_stat_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChallengeStatSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_stat_value = tmp;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.challenge_stat_path)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.current_stat_value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.current_stat_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.challenge_stat_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.challenge_stat_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.current_stat_value != 0 {
            os.write_int32(1, self.current_stat_value)?;
        }
        if !self.challenge_stat_path.is_empty() {
            os.write_string(2, &self.challenge_stat_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChallengeStatSaveGameData {
        ChallengeStatSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "current_stat_value",
                |m: &ChallengeStatSaveGameData| { &m.current_stat_value },
                |m: &mut ChallengeStatSaveGameData| { &mut m.current_stat_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "challenge_stat_path",
                |m: &ChallengeStatSaveGameData| { &m.challenge_stat_path },
                |m: &mut ChallengeStatSaveGameData| { &mut m.challenge_stat_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChallengeStatSaveGameData>(
                "ChallengeStatSaveGameData",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ChallengeStatSaveGameData {
        static instance: ::protobuf::rt::LazyV2<ChallengeStatSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChallengeStatSaveGameData::new)
    }
}

impl ::protobuf::Clear for ChallengeStatSaveGameData {
    fn clear(&mut self) {
        self.current_stat_value = 0;
        self.challenge_stat_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChallengeStatSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeStatSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct OakChallengeRewardSaveGameData {
    // message fields
    pub challenge_reward_claimed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OakChallengeRewardSaveGameData {
    fn default() -> &'a OakChallengeRewardSaveGameData {
        <OakChallengeRewardSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl OakChallengeRewardSaveGameData {
    pub fn new() -> OakChallengeRewardSaveGameData {
        ::std::default::Default::default()
    }

    // bool challenge_reward_claimed = 1;


    pub fn get_challenge_reward_claimed(&self) -> bool {
        self.challenge_reward_claimed
    }
    pub fn clear_challenge_reward_claimed(&mut self) {
        self.challenge_reward_claimed = false;
    }

    // Param is passed by value, moved
    pub fn set_challenge_reward_claimed(&mut self, v: bool) {
        self.challenge_reward_claimed = v;
    }
}

impl ::protobuf::Message for OakChallengeRewardSaveGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.challenge_reward_claimed = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.challenge_reward_claimed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.challenge_reward_claimed != false {
            os.write_bool(1, self.challenge_reward_claimed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OakChallengeRewardSaveGameData {
        OakChallengeRewardSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "challenge_reward_claimed",
                |m: &OakChallengeRewardSaveGameData| { &m.challenge_reward_claimed },
                |m: &mut OakChallengeRewardSaveGameData| { &mut m.challenge_reward_claimed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OakChallengeRewardSaveGameData>(
                "OakChallengeRewardSaveGameData",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static OakChallengeRewardSaveGameData {
        static instance: ::protobuf::rt::LazyV2<OakChallengeRewardSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OakChallengeRewardSaveGameData::new)
    }
}

impl ::protobuf::Clear for OakChallengeRewardSaveGameData {
    fn clear(&mut self) {
        self.challenge_reward_claimed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OakChallengeRewardSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OakChallengeRewardSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct ChallengeSaveGameData {
    // message fields
    pub completed_count: i32,
    pub is_active: bool,
    pub currently_completed: bool,
    pub completed_progress_level: i32,
    pub progress_counter: i32,
    pub stat_instance_state: ::protobuf::RepeatedField<ChallengeStatSaveGameData>,
    pub challenge_class_path: ::std::string::String,
    pub challenge_reward_info: ::protobuf::RepeatedField<OakChallengeRewardSaveGameData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChallengeSaveGameData {
    fn default() -> &'a ChallengeSaveGameData {
        <ChallengeSaveGameData as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeSaveGameData {
    pub fn new() -> ChallengeSaveGameData {
        ::std::default::Default::default()
    }

    // int32 completed_count = 1;


    pub fn get_completed_count(&self) -> i32 {
        self.completed_count
    }
    pub fn clear_completed_count(&mut self) {
        self.completed_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_completed_count(&mut self, v: i32) {
        self.completed_count = v;
    }

    // bool is_active = 2;


    pub fn get_is_active(&self) -> bool {
        self.is_active
    }
    pub fn clear_is_active(&mut self) {
        self.is_active = false;
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = v;
    }

    // bool currently_completed = 3;


    pub fn get_currently_completed(&self) -> bool {
        self.currently_completed
    }
    pub fn clear_currently_completed(&mut self) {
        self.currently_completed = false;
    }

    // Param is passed by value, moved
    pub fn set_currently_completed(&mut self, v: bool) {
        self.currently_completed = v;
    }

    // int32 completed_progress_level = 4;


    pub fn get_completed_progress_level(&self) -> i32 {
        self.completed_progress_level
    }
    pub fn clear_completed_progress_level(&mut self) {
        self.completed_progress_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_completed_progress_level(&mut self, v: i32) {
        self.completed_progress_level = v;
    }

    // int32 progress_counter = 5;


    pub fn get_progress_counter(&self) -> i32 {
        self.progress_counter
    }
    pub fn clear_progress_counter(&mut self) {
        self.progress_counter = 0;
    }

    // Param is passed by value, moved
    pub fn set_progress_counter(&mut self, v: i32) {
        self.progress_counter = v;
    }

    // repeated .OakSave.ChallengeStatSaveGameData stat_instance_state = 6;


    pub fn get_stat_instance_state(&self) -> &[ChallengeStatSaveGameData] {
        &self.stat_instance_state
    }
    pub fn clear_stat_instance_state(&mut self) {
        self.stat_instance_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_instance_state(&mut self, v: ::protobuf::RepeatedField<ChallengeStatSaveGameData>) {
        self.stat_instance_state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_instance_state(&mut self) -> &mut ::protobuf::RepeatedField<ChallengeStatSaveGameData> {
        &mut self.stat_instance_state
    }

    // Take field
    pub fn take_stat_instance_state(&mut self) -> ::protobuf::RepeatedField<ChallengeStatSaveGameData> {
        ::std::mem::replace(&mut self.stat_instance_state, ::protobuf::RepeatedField::new())
    }

    // string challenge_class_path = 7;


    pub fn get_challenge_class_path(&self) -> &str {
        &self.challenge_class_path
    }
    pub fn clear_challenge_class_path(&mut self) {
        self.challenge_class_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge_class_path(&mut self, v: ::std::string::String) {
        self.challenge_class_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_class_path(&mut self) -> &mut ::std::string::String {
        &mut self.challenge_class_path
    }

    // Take field
    pub fn take_challenge_class_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.challenge_class_path, ::std::string::String::new())
    }

    // repeated .OakSave.OakChallengeRewardSaveGameData challenge_reward_info = 8;


    pub fn get_challenge_reward_info(&self) -> &[OakChallengeRewardSaveGameData] {
        &self.challenge_reward_info
    }
    pub fn clear_challenge_reward_info(&mut self) {
        self.challenge_reward_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge_reward_info(&mut self, v: ::protobuf::RepeatedField<OakChallengeRewardSaveGameData>) {
        self.challenge_reward_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_challenge_reward_info(&mut self) -> &mut ::protobuf::RepeatedField<OakChallengeRewardSaveGameData> {
        &mut self.challenge_reward_info
    }

    // Take field
    pub fn take_challenge_reward_info(&mut self) -> ::protobuf::RepeatedField<OakChallengeRewardSaveGameData> {
        ::std::mem::replace(&mut self.challenge_reward_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChallengeSaveGameData {
    fn is_initialized(&self) -> bool {
        for v in &self.stat_instance_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge_reward_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.completed_count = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.currently_completed = tmp;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.completed_progress_level = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.progress_counter = tmp;
                }
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_instance_state)?;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.challenge_class_path)?;
                }
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.challenge_reward_info)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.completed_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.completed_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_active != false {
            my_size += 2;
        }
        if self.currently_completed != false {
            my_size += 2;
        }
        if self.completed_progress_level != 0 {
            my_size += ::protobuf::rt::value_size(4, self.completed_progress_level, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.progress_counter != 0 {
            my_size += ::protobuf::rt::value_size(5, self.progress_counter, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stat_instance_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.challenge_class_path.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.challenge_class_path);
        }
        for value in &self.challenge_reward_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.completed_count != 0 {
            os.write_int32(1, self.completed_count)?;
        }
        if self.is_active != false {
            os.write_bool(2, self.is_active)?;
        }
        if self.currently_completed != false {
            os.write_bool(3, self.currently_completed)?;
        }
        if self.completed_progress_level != 0 {
            os.write_int32(4, self.completed_progress_level)?;
        }
        if self.progress_counter != 0 {
            os.write_int32(5, self.progress_counter)?;
        }
        for v in &self.stat_instance_state {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.challenge_class_path.is_empty() {
            os.write_string(7, &self.challenge_class_path)?;
        }
        for v in &self.challenge_reward_info {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChallengeSaveGameData {
        ChallengeSaveGameData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "completed_count",
                |m: &ChallengeSaveGameData| { &m.completed_count },
                |m: &mut ChallengeSaveGameData| { &mut m.completed_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_active",
                |m: &ChallengeSaveGameData| { &m.is_active },
                |m: &mut ChallengeSaveGameData| { &mut m.is_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "currently_completed",
                |m: &ChallengeSaveGameData| { &m.currently_completed },
                |m: &mut ChallengeSaveGameData| { &mut m.currently_completed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "completed_progress_level",
                |m: &ChallengeSaveGameData| { &m.completed_progress_level },
                |m: &mut ChallengeSaveGameData| { &mut m.completed_progress_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "progress_counter",
                |m: &ChallengeSaveGameData| { &m.progress_counter },
                |m: &mut ChallengeSaveGameData| { &mut m.progress_counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChallengeStatSaveGameData>>(
                "stat_instance_state",
                |m: &ChallengeSaveGameData| { &m.stat_instance_state },
                |m: &mut ChallengeSaveGameData| { &mut m.stat_instance_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "challenge_class_path",
                |m: &ChallengeSaveGameData| { &m.challenge_class_path },
                |m: &mut ChallengeSaveGameData| { &mut m.challenge_class_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OakChallengeRewardSaveGameData>>(
                "challenge_reward_info",
                |m: &ChallengeSaveGameData| { &m.challenge_reward_info },
                |m: &mut ChallengeSaveGameData| { &mut m.challenge_reward_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChallengeSaveGameData>(
                "ChallengeSaveGameData",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static ChallengeSaveGameData {
        static instance: ::protobuf::rt::LazyV2<ChallengeSaveGameData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChallengeSaveGameData::new)
    }
}

impl ::protobuf::Clear for ChallengeSaveGameData {
    fn clear(&mut self) {
        self.completed_count = 0;
        self.is_active = false;
        self.currently_completed = false;
        self.completed_progress_level = 0;
        self.progress_counter = 0;
        self.stat_instance_state.clear();
        self.challenge_class_path.clear();
        self.challenge_reward_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChallengeSaveGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeSaveGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10oak_shared.proto\x12\x07OakSave\"8\n\x04Vec3\x12\x0e\n\x01x\x18\
    \x01\x20\x01(\x02R\x01xB\0\x12\x0e\n\x01y\x18\x02\x20\x01(\x02R\x01yB\0\
    \x12\x0e\n\x01z\x18\x03\x20\x01(\x02R\x01zB\0:\0\"X\n\x14GameStatSaveGam\
    eData\x12\x1f\n\nstat_value\x18\x01\x20\x01(\x05R\tstatValueB\0\x12\x1d\
    \n\tstat_path\x18\x02\x20\x01(\tR\x08statPathB\0:\0\"\x80\x01\n\x19Inven\
    toryCategorySaveData\x12C\n\x1dbase_category_definition_hash\x18\x01\x20\
    \x01(\rR\x1abaseCategoryDefinitionHashB\0\x12\x1c\n\x08quantity\x18\x02\
    \x20\x01(\x05R\x08quantityB\0:\0\"[\n\x12OakSDUSaveGameData\x12\x1d\n\ts\
    du_level\x18\x01\x20\x01(\x05R\x08sduLevelB\0\x12$\n\rsdu_data_path\x18\
    \x02\x20\x01(\tR\x0bsduDataPathB\0:\0\"\x8d\x01\n!RegisteredDownloadable\
    Entitlement\x12\x10\n\x02id\x18\x01\x20\x01(\x05R\x02idB\0\x12\x1c\n\x08\
    consumed\x18\x02\x20\x01(\rR\x08consumedB\0\x12\x20\n\nregistered\x18\
    \x03\x20\x01(\x08R\nregisteredB\0\x12\x14\n\x04seen\x18\x04\x20\x01(\x08\
    R\x04seenB\0:\0\"\xe8\x01\n\"RegisteredDownloadableEntitlements\x12C\n\
    \x1dentitlement_source_asset_path\x18\x01\x20\x01(\tR\x1aentitlementSour\
    ceAssetPathB\0\x12)\n\x0fentitlement_ids\x18\x02\x20\x03(\x03R\x0eentitl\
    ementIdsB\0\x12P\n\x0centitlements\x18\x03\x20\x03(\x0b2*.OakSave.Regist\
    eredDownloadableEntitlementR\x0centitlementsB\0:\0\"\x7f\n\x19ChallengeS\
    tatSaveGameData\x12.\n\x12current_stat_value\x18\x01\x20\x01(\x05R\x10cu\
    rrentStatValueB\0\x120\n\x13challenge_stat_path\x18\x02\x20\x01(\tR\x11c\
    hallengeStatPathB\0:\0\"^\n\x1eOakChallengeRewardSaveGameData\x12:\n\x18\
    challenge_reward_claimed\x18\x01\x20\x01(\x08R\x16challengeRewardClaimed\
    B\0:\0\"\xe8\x03\n\x15ChallengeSaveGameData\x12)\n\x0fcompleted_count\
    \x18\x01\x20\x01(\x05R\x0ecompletedCountB\0\x12\x1d\n\tis_active\x18\x02\
    \x20\x01(\x08R\x08isActiveB\0\x121\n\x13currently_completed\x18\x03\x20\
    \x01(\x08R\x12currentlyCompletedB\0\x12:\n\x18completed_progress_level\
    \x18\x04\x20\x01(\x05R\x16completedProgressLevelB\0\x12+\n\x10progress_c\
    ounter\x18\x05\x20\x01(\x05R\x0fprogressCounterB\0\x12T\n\x13stat_instan\
    ce_state\x18\x06\x20\x03(\x0b2\".OakSave.ChallengeStatSaveGameDataR\x11s\
    tatInstanceStateB\0\x122\n\x14challenge_class_path\x18\x07\x20\x01(\tR\
    \x12challengeClassPathB\0\x12]\n\x15challenge_reward_info\x18\x08\x20\
    \x03(\x0b2'.OakSave.OakChallengeRewardSaveGameDataR\x13challengeRewardIn\
    foB\0:\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
